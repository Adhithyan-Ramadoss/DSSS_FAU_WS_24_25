"""
This script contains the methods to randomly load N images (with the respective segmentation mask and the meta data) of
the MiniBAGLS dataset.
This script also plots the images, metadata and the segmentation masks.

Author: Ramadoss, Adhithyan
06.11.2024
"""
import os
from glob import glob
import random
from PIL import Image
import numpy as np
import json
import matplotlib.pyplot as plt
from typing import List, Tuple


def collect_file_names(search_dir: str, file_name_pattern:str, file_extn: str) -> List:
    """
    This function recursively searches for files of specific file extensions in a given directory and returns a list of
    absolute file paths for all the files that meet the match criterion.
    Args:
        search_dir (str): The file directory where the search must be conducted
        file_name_pattern (str): The searched pattern to be used for a file.
        If no specific pattern and the search only to be done by extn pass "*" to this argument
        file_extn (str): The extension type of the files that are being searched

    Returns:
        List: A list of absolute file paths for all the files that meet the match criterion

    Rises:
        ValueError: If the given search directory (search_dir) doesn't exist
    """
    if not os.path.isdir(search_dir):
        raise ValueError(f"The given search directory ('{search_dir}') doesn't exist. Please provide a valid directory path.")

    # Recursively collect the file path of all the files that meet the search criterion
    img_files = glob(os.path.join(search_dir, f"{file_name_pattern}.{file_extn}"), recursive=True)
    return img_files

def collect_data_and_label(unique_files_list: List[str]) -> list[tuple[str, str, str]]:
        """
        Args:
            unique_files_list (List[str]): List of all unique file names that could be used to combine the input,
            label and mata data
        Returns:
            List[Tuple[str, str, str]]: A list of tuples, where each tuple has (<DATA>, <DATA_SEGMENT_LABEL>, <DATA_META_INFO>)

        Requires:
            This method should only be used on the result generated by "collect_file_names" method.
            Other this may fail.

        Note:
        The mechanism to collect the file names is unique to the given set of files and would not work directly in a
        general sense - Hard coded indices for quick processing
        """
        file_name_tuples = [(file_name[:-8] + file_name[-4:], file_name, file_name[:-8] + ".meta") for file_name in
                          unique_files_list]
        return file_name_tuples

def plot_data(file_pairs: List[Tuple[str, str, str]]) -> None:
    """
    This method collects the base data, the segment masks and creates a subplot with the segmentation masks overlaid on
     the base image, with the appropriate "Subject disorder status" as the plot sub title
    Args:
        file_pairs (List[Tuple[str, str, str]]): list of tuple containing (<DATA>, <DATA_SEGMENT_LABEL>, <DATA_META_INFO>)

    Returns:
        None

    Requires:
        This method should only be used on the result generated by "collect_data_and_label" method.
        Other this may fail.
    """
    fig, axs = plt.subplots(int(np.ceil(len(file_pairs)/2)), 2)
    for i, file_pair in enumerate(file_pairs):
        base_image = Image.open(file_pair[0])
        base_data = np.array(base_image)

        base_seg_image = Image.open(file_pair[1])
        base_seg = np.array(base_seg_image)
        # Read the metadata as a json JSON data from the file
        with open(file_pair[2], 'r') as meta_file:
            data = json.load(meta_file)
            plt_title = data["Subject disorder status"]

            # processing the title to prevent them from overlapping
            if len(plt_title.split()) > 3:
                plt_title = "\n".join([" ".join(plt_title.split()[i:i + 3]) for i in range(0, len(plt_title.split()), 3)])

        # The segmentation is white in active regions and black everywhere else, we can exploit this fact to place a red
        # segment mask to be overlaid on the base image.
        # Do a element wise max operation between the base image and the modified segment mask on the red channel
        # and leave the G and B channels of the base image unchanged
        masked_data = np.stack((np.maximum(base_data[:,:,0], base_seg), base_data[:,:,1], base_data[:,:,2]), axis=2)
        axs[i//2, i%2].imshow(masked_data, cmap='Blues')
        axs[i//2, i%2].set_title(plt_title)
        axs[i//2, i%2].set_xticks([])
        axs[i//2, i%2].set_yticks([])
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    # # Setting a random seed to ensure repeatability - could be commented out during actual run
    # random.seed(42)

    # Searching for files with "<number>_seg" name pattern to first get the list of unique files, after which
    # the base file name could be extracted for further use.
    png_seg_files = collect_file_names("./Mini_BAGLS_dataset", "*_seg","png")
    png_files_sets = collect_data_and_label(png_seg_files)

    # number of data points to be randomly sampled from the dataset
    no_data_points = 4
    data_to_plot = random.sample(png_files_sets, no_data_points)
    plot_data(data_to_plot)
